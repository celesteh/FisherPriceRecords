FisherPriceRecords {

	classvar <allNotes, <allowedNotes, playableDegrees;

	var midiEvents, transposition, lowestNote, degrees, str, <>title, source;

	*initClass {

		var notenames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

		allNotes = 127.collect({|i|
			(notenames.wrapAt(i) ++ (i.div(12) + 2)).asSymbol;
		});

		allowedNotes = ["D#4", "G#4", "A#4", "C5", "D#5", "F5", "G#5", "A#5", "C6", "C#6", "D#6", "F6", "G6", "G#6", "A#6"].collect({|note|
			allNotes.indexOf(note.asSymbol);
		});

		playableDegrees = allowedNotes - allowedNotes[0];

	}

	* new{|midiEvents, title, source|

		^super.new.init(midiEvents, title, source);
	}

	init {|midiArr, name, src|

		midiEvents = midiArr;
		title = name;
		source = src;
		str="";
		this.findTransposition;
		//this.realise;

	}

	realise{|repeats=1, length|

		var noteEvents, note, time, noteStr;

		length.isNil.if({ repeats = 1; length = 0;});

		noteEvents = midiEvents.select({|evt|
			(evt[2] == \noteOn)
		});

		repeats.do({|i|
			noteEvents.do({|n|
				(n[5]!= 0).if({ // velocity is not 0
					note = allNotes[this.map(n[4])];
					time = n[1] + (i * length);

					noteStr = "[[\"%\"], %],\n".format(note, time);
					str = str ++ noteStr;
				});
			})
		});
	}

	map {|note|

		var degree, output;

		degree = note - lowestNote + transposition;

		output = allowedNotes[degree];
		output.isNil.if({
			output = allowedNotes[degree + 12];
			output.isNil.if({
				output = allowedNotes[degree -12];
				output.isNil.if({
					"this shouldn't happen".warn;
		})})});

		^output

	}

	findTransposition {
		var notes, note, found, degs, allowed_degrees, find_outside, match, min, lowest,
		outside;

		notes = [];
		found = [];
		allowed_degrees = allowedNotes - allowedNotes[0];

		midiEvents.do({|evt|
			(evt[2] == \noteOn).if ({
				note = evt[4];
				notes.includes(note).not.if({
					notes = notes ++ note;
				})
			})
		});
		notes = notes.sort;

		lowestNote = notes[0];
		degs = notes-lowestNote;
		degrees = degs;

		find_outside = { |degs|

			var notfound, index, flag;

			notfound = [];
			index = 0;
			flag = false;

			"in find_outside".postln;

			degs.do({|d, i|
				flag = false;
				"in loop".postln;
				{ flag.not && (index < allowed_degrees.size) }. while({
					"checking".postln;
					(d == allowed_degrees[index]).if({
						// found!
						flag = true;
					}, { (d > allowed_degrees[index]).if({
						// advance the index
						index = index + 1;
					}, { (d < allowed_degrees[index]).if({
						// check octave transposition
						allowed_degrees.indexOf(d+12).notNil.if({
							flag = true; // off by an octave, but ok
						}, { allowed_degrees.indexOf(d-12).notNil.if({
							flag = true; // off by an octave, but ok
						}, {
							// not found
							notfound = notfound ++ i;
							d.postln;
							(index > 0).if( { index = index - 1}); // back up
							flag = true;
					})})})})})
				})
			});

			notfound.postln;
			notfound = notfound.collect({|i| notes[i] });
			notfound.postln;
			notfound;
		};

		found = [];
		match = false;
		degs = notes-notes[0];
		//degs.postln;

		{match.not && (degs.last <= allowed_degrees.last)}.while({

			found = found.add(find_outside.(degrees));
			found.last.postln;
			(found.last.size == 0).if ({
				match = true;
			} , {
				degs = degs + 1;
			});
		});

		match.if({
			"Transposition found!".postln;
			transposition = (found.size -1) + allowedNotes[0];
			degrees = degs;
		}, {
			min = inf;

			found.do({|arr, index|
				//min = arr.size.min(min);
				(min > arr.size).if({
					transposition = index;// + allowedNotes[0];
					outside = arr;
					min = arr.size;
					degrees = degrees + transposition;
				})
			});

			outside = outside.collect({|note|
			//	note = note + notes[0] - transposition;
				allNotes[note]
			});

			"Best match has low note % and has % outside notes:\n %".format(allNotes[notes[0]],min, outside).warn;
		});

	}

	write{|filename|

		var file;

		file = File(filename.standardizePath, "w");
		file.write("// OpenSCAD file - http://www.openscad.org\n");

		source.notNil.if({
			file.write("// converted from % by SuperCollider".format(source.asString));
		}, {
			file.write("// converted / generated by SuperCollider\n");
		});

		file.write("""//
include <fpRecordModule.scad>

// Notes you can use:
// notes with a \"_2\" are double and can also be written without the \"_2\".
//
//C5, F5, G5,
//C6_2, F6_2, G6,
//
//D#4, G#4, A#4,
//D#5, G#5_2, A#5_2,
//C#6_2, D#6_2, G#6,A#6,
//the b is represented as a -
//E-4, A-4, B-4,
//E-5, A-5_2, B-5_2,
//D-6_2, E-6_2, A-6, B-6

composition = [
""" );
		file.write(this.asString);
		file.write("];\n\n\n");
		file.write("writeText(\"%\", y=8, size=6);\n".format(title));

		file.write("""

// That's all!
""");

		file.close;
	}

	asString{

		str.isNil.if({
			this.realise
		});

		^str
	}
}